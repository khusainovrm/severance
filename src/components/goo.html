<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Black Goo Dripping in Three.js</title>
  <style>
      body { margin: 0; }
      canvas { display: block; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
<script>
  const scene = new THREE.Scene();
  const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  const renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Uniforms for shader
  const uniforms = {
    time: { value: 0.0 },
    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
  };

  // ShaderMaterial with GLSL raymarching
  const material = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4(position, 1.0);
                }
            `,
    fragmentShader: `
                uniform float time;
                uniform vec2 resolution;
                varying vec2 vUv;

                float sdSphere(vec3 p, float r) {
                    return length(p) - r;
                }

                float smin(float a, float b, float k) {
                    float h = max(k - abs(a - b), 0.0) / k;
                    return min(a, b) - h * h * h * k * (1.0 / 6.0);
                }

                float sdf(vec3 pos) {
                    float d = sdSphere(pos + vec3(sin(time), 0.0, 0.0), 0.5);
                    d = smin(d, sdSphere(pos + vec3(0.0, sin(time * 0.5) * -1.0, 0.0), 0.3), 0.5);
                    d = smin(d, sdSphere(pos + vec3(sin(time * 1.5), cos(time) * -0.5, 0.0), 0.4), 0.6);
                    return d;
                }

                void main() {
                    vec2 uv = (vUv * 2.0 - 1.0) * (resolution / resolution.y);
                    vec3 rayOrigin = vec3(0.0, 0.0, -3.0);
                    vec3 rayDirection = normalize(vec3(uv, 1.0));
                    float t = 0.0;

                    for (int i = 0; i < 80; i++) {
                        vec3 pos = rayOrigin + rayDirection * t;
                        float d = sdf(pos);
                        t += d;
                        if (d < 0.001 || t > 100.0) break;
                    }

                    // Black goo with subtle depth shading
                    vec3 color = vec3(0.0) + vec3(t * 0.01);
                    gl_FragColor = vec4(color, 1.0);
                }
            `,
    side: THREE.BackSide
  });

  const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
  scene.add(mesh);

  function animate() {
    requestAnimationFrame(animate);
    uniforms.time.value += 0.05; // Adjust speed for dripping
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>