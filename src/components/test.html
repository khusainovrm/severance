<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Черная вязкая жижа</title>
  <style>
      body {
          margin: 0;
          padding: 0;
          overflow: hidden;
          background: #1a1a1a;
      }
      canvas {
          display: block;
      }
      .controls {
          position: absolute;
          top: 20px;
          left: 20px;
          color: white;
          font-family: Arial, sans-serif;
          background: rgba(0,0,0,0.7);
          padding: 10px;
          border-radius: 5px;
      }
  </style>
</head>
<body>
<div class="controls">
  <div>Вязкость: <input type="range" id="viscosity" min="0.1" max="2" value="1" step="0.1"></div>
  <div>Интенсивность: <input type="range" id="intensity" min="0.1" max="3" value="1.5" step="0.1"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
  let scene, camera, renderer, gooMaterial;
  let gooGeometry, gooMesh;
  let clock = new THREE.Clock();

  // Параметры анимации для смолы
  let speed = 1.0;
  let waveCount = 2;
  let intensity = 2.2;
  let viscosity = 1.6;

  // Vertex shader для медленной деформации смолы
  const vertexShader = `
            uniform float time;
            uniform float speed;
            uniform float waveCount;
            uniform float intensity;
            uniform float viscosity;

            varying vec3 vPosition;
            varying vec3 vNormal;

            float noise(vec3 p) {
                return sin(p.x * 1.2) * cos(p.y * 0.8) * sin(p.z * 1.1) * 0.5 + 0.5;
            }

            void main() {
                vPosition = position;
                vNormal = normal;

                vec3 pos = position;

                // Динамическое количество волн
                float totalWave = 0.0;
                float waveWeight = 1.0;

                for(float i = 1.0; i <= 5.0; i++) {
                    if(i <= waveCount) {
                        float freq = 1.5 - i * 0.3;
                        float amp = 0.15 / i;
                        float phase = time * speed * viscosity * (0.3 - i * 0.05);

                        totalWave += sin(pos.x * freq + phase) * amp * waveWeight;
                        totalWave += cos(pos.z * freq * 0.8 + phase * 0.7) * amp * 0.8 * waveWeight;

                        waveWeight *= 0.8; // Уменьшаем влияние каждой следующей волны
                    }
                }

                // Медленный шум для органичности
                float noiseVal = noise(pos * 1.0 + time * speed * viscosity * 0.1);

                // Фактор свисания - сильнее внизу
                float hangFactor = smoothstep(0.3, -1.0, pos.y);

                // Деформация с упором на вертикальное стекание
                pos.y -= totalWave * intensity * hangFactor * 0.8;
                pos.x += totalWave * 0.2 * hangFactor;
                pos.z += totalWave * 0.2 * hangFactor;

                // Тонкий шум для поверхности
                pos += normal * noiseVal * 0.03 * intensity * hangFactor;

                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

  // Fragment shader для создания вида смолы/чернил
  const fragmentShader = `
            uniform float time;
            varying vec3 vPosition;
            varying vec3 vNormal;

            void main() {
                vec3 viewDirection = normalize(cameraPosition - vPosition);
                float fresnel = 1.0 - max(0.0, dot(viewDirection, normalize(vNormal)));

                // Глубокий черный цвет смолы
                vec3 baseColor = vec3(0.02, 0.015, 0.025);

                // Сильные блики как у густой жидкости
                float highlight = pow(fresnel, 1.5) * 0.6;
                vec3 highlightColor = vec3(0.3, 0.25, 0.35);

                // Внутренние отражения для глубины
                float depth = 1.0 - fresnel;
                baseColor *= (1.0 + depth * 0.2);

                // Очень тонкие цветовые переливы как у нефти
                float iridescence = sin(vPosition.x * 15.0 + vPosition.z * 12.0 + time * 0.5) * 0.01;
                vec3 iridColor = vec3(0.1, 0.05, 0.15);

                vec3 finalColor = baseColor + highlight * highlightColor + iridescence * iridColor;

                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

  function init() {
    // Сцена
    scene = new THREE.Scene();

    // Камера статична
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0.5, 2.5);
    camera.lookAt(0, -0.2, 0);

    // Рендерер
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x1a1a1a);
    document.body.appendChild(renderer.domElement);

    // Создание геометрии для жижи
    createGooGeometry();

    // Материал с шейдерами
    gooMaterial = new THREE.ShaderMaterial({
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      uniforms: {
        time: { value: 0 },
        speed: { value: speed },
        waveCount: { value: waveCount },
        intensity: { value: intensity },
        viscosity: { value: viscosity }
      },
      side: THREE.DoubleSide
    });

    gooMesh = new THREE.Mesh(gooGeometry, gooMaterial);
    scene.add(gooMesh);

    // Освещение
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(1, 1, 1);
    scene.add(directionalLight);

    // Обработчики для контролов
    setupControls();

    // Обработчик изменения размера окна
    window.addEventListener('resize', onWindowResize, false);
  }

  function createGooGeometry() {
    // Создаем базовую геометрию
    const width = 2;
    const height = 1;
    const depth = 2;
    const widthSegments = 32;
    const heightSegments = 24;
    const depthSegments = 32;

    gooGeometry = new THREE.BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments);

    // Модифицируем геометрию для создания свисающих форм
    const positions = gooGeometry.attributes.position.array;

    for (let i = 0; i < positions.length; i += 3) {
      const x = positions[i];
      const y = positions[i + 1];
      const z = positions[i + 2];

      // Создаем форму, которая свисает вниз
      if (y > 0.3) {
        // Верхняя часть остается плоской
        positions[i + 1] = 0.5;
      } else {
        // Нижняя часть становится более неровной и свисающей
        const distanceFromCenter = Math.sqrt(x * x + z * z);
        const dropFactor = Math.max(0, 1 - distanceFromCenter * 0.8);
        positions[i + 1] = y - dropFactor * 0.5;
      }
    }

    gooGeometry.attributes.position.needsUpdate = true;
    gooGeometry.computeVertexNormals();
  }

  function setupControls() {
    const viscositySlider = document.getElementById('viscosity');
    const intensitySlider = document.getElementById('intensity');

    viscositySlider.addEventListener('input', (e) => {
      viscosity = parseFloat(e.target.value);
      gooMaterial.uniforms.viscosity.value = viscosity;
    });

    intensitySlider.addEventListener('input', (e) => {
      intensity = parseFloat(e.target.value);
      gooMaterial.uniforms.intensity.value = intensity;
    });
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function animate() {
    requestAnimationFrame(animate);

    const elapsedTime = clock.getElapsedTime();

    // Обновляем время в шейдере
    gooMaterial.uniforms.time.value = elapsedTime;

    // Камера остается статичной

    renderer.render(scene, camera);
  }

  // Запуск
  init();
  animate();
</script>
</body>
</html>